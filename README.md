# AndroidBasic
android 基础知识整理
activity启动模式 未完成(源码验证)



线程池

       我们在多线程开发中，经常会用到线程池，线程池内部存储了一个或多个线程，开发者只需要将操作封装成Runnable提交给线程池去执行就好了，而不需要自己创建线程，使用线程池的好处有：
1、方便开发者统一管理线程；
2、能够节省创建以及销毁线程造成的开销，因为线程池中的线程是可以复用的；
3、能够灵活的指定满足不同功能的线程池。
线程池能够灵活的配置核心线程数、最大线程数、非核心线程闲置时的超时时长、线程池的任务队列、创建线程的工厂、处理异常情况的Handler等参数，我们可以根据需求来配置线程池，ThreadPoolExecutor执行任务时大致遵循如下规则：
（1）如果线程池中有空闲的核心线程，那么会直接使用一个核心线程来执行任务；

（2）如果线程池中没有空闲的核心线程来执行任务，那么会将任务插入到任务队列中排队等待执行；

（3）如果在步骤2中无法将任务插入到任务队列中，这往往是因为任务队列已满，这个时候如果线程数量没有达到线程池规定的最大个数，则会立即启动一个非核心线程来处理任务；

（4）如果在步骤3中线程数量已经达到了线程池规定的最大个数，那么就拒绝执行此任务，线程池会调用RejectedExecutionHandler的rejectedExecution方法来处理异常情况。

为什么线程池要在任务队列已经满了的时候才创建非核心线程处理任务
我的理解是线程的创建和回收都需要销毁资源，线程的创建需要内存和CPU，线程的回收也需要销毁CPU执行时间，而非核心线程只是临时创建的线程，只有当任务很多，任务队列填充满了的情况下才会创建，当任务数量恢复正常后，非核心线程数是要被回收的，其代价要比将任务放入任务队列要大，同时这也违背了线程池复用线程的原则，也就是说，我们首先应该让任务在任务队列中排队等待执行，只有特殊情况才创建非核心线程来处理。

线程池处理异常情况一般怎么处理
如果当前任务队列已经满了，并且开启的线程数也达到了最大线程数，这是就要采用异常处理机制来处理任务了，线程池提供了四种默认的异常处理机制：
1、CallerRunsPolicy
直接让请求执行任务的线程执行任务，这种策略可以延缓任务的产生速度，因为产生任务的线程会去执行任务，采用这种方式的问题是可能会阻塞产生任务的线程，比如在UI线程中执行耗时任务就会造成UI界面卡顿。

2、AbortPolicy
直接抛出异常并丢弃任务，让产生任务的线程捕获异常做相应的处理。

3、DiscardPolicy
直接丢弃任务，不做任何处理。

4、DiscardOldestPolicy
这种策略会丢弃任务队列头部的任务，然后尝试将新任务加入到队列中，要谨慎采用这种策略，这种策略采用的是丢弃旧的任务来容纳新的任务，不能确保任务能够执行。

一般的，如果出现了异常情况，这往往是因为产生任务的速度远远大于执行任务的速度，这是，我们需要考虑我们的线程池配置参数是否合理，比如核心线程数是不是太小了，或者CPU的处理能力不够，来不及处理任务。
我们也可以实现RejectedExecutionHandler接口来实现自己的异常处理机制，比如记录日志、报警等功能。

